
\chapter{Wstêpna analiza danych}
\thispagestyle{fancy}

<<>>=

@

\section{Podstawowe charakterystyki zmiennych}

\subsection{Zmienne ilo¶ciowe}

\begin{table}[h]

\begin{center}
\begin{tabular}{ l rrrrrrr} \toprule
  & genergy & gpuls & gdenergy & gdpuls & nbumps & energy & maxenergy \\ \toprule
<<results='asis', echo=FALSE,cache=TRUE>>=
m <- numeric(11)
m <- apply(se[,-c(1:3,8,10:13,16)], 2, sd)

m <- formatC(m, digits = 2, format = "f")

cat("Odchylenie St&",paste(m, collapse="&") )
@
\\ 
<<results='asis',echo=FALSE,cache=TRUE>>=
   m <- numeric(11)
m <- apply(se[,-c(1:3,8,10:13,16)], 2, var)

m <- formatC(m, digits = 2, format = "f")

cat("Wariancja&",paste(m, collapse="&") )
@
\\ 
<<results='asis',echo=FALSE,cache=TRUE>>=
   m <- numeric(11)
m <- apply(se[,-c(1:3,8,10:13,16)], 2, median)

m <- formatC(m, digits = 2, format = "f")

cat("Mediana&",paste(m, collapse="&") )
@
\\ 
<<results='asis',echo=FALSE,cache=TRUE>>=
   m <- numeric(11)
m <- apply(se[,-c(1:3,8,10:13,16)], 2, mean)

m <- formatC(m, digits = 2, format = "f")

cat("¦rednia&",paste(m, collapse="&") )
@
\\ \bottomrule
\end{tabular}
\end{center}
\caption[Podstawowe statystyki agreguj±ce dla zmiennych ci±g³ych]{Podstawowe statystyki agreguj±ce dla zmiennych ci±g³ych.}
\end{table}

\subsection{Korelacja miêdzy zmiennymi ci±g³ymi}
<<echo=FALSE,cache=TRUE>>=
# testy na normalnosc apply(se[,-c(1:3,8,16)],2,shapiro.test)
cor <- apply(formatC(cor(se[,-c(1:3,8,16)],method="spearman"),digits=2, format="f"),2,as.numeric)
rownames(cor) <- colnames(cor)
cor
@

\subsection{Zmienna obja¶niana}

Poni¿ej widoczny jest podzia³ klas w naszym zbiorze danych:

<<>>=
   summary(se[,16])
@

\section{Usuniêcie braków danych, wstêpna selekcja}

W naszym zbiorze nie wystêpuj± braki danych.

\bigskip

Na pierwszy rzut oka widaæ, ¿e niektóre zmienne s± zupe³nie nieistotne lub bardzo ze sob± skorelowane, dlatego chcieliby¶my od razu usun±æ je z analizy. Przyjrzyjmy siê naszym danym:
   
<<echo=FALSE,cache=TRUE>>=
library("foreign")
se <- read.arff("http://archive.ics.uci.edu/ml/machine-learning-databases/00266/seismic-bumps.arff")
head(se,3)
@


\bigskip

Zacznijmy od zmiennych \textit{nbumps6, nbumps7} oraz \textit{nbumps89}. S± to zmienne ilo¶ciowe, wszystkie jednak przyjmuj± warto¶æ zero. Niczego wiêc nie wnosz± one do naszej analizy. Zast±pmy je wiêc przez zmienn± \textit{nbumps5} (a raczej rozszerzmy definicjê zmiennej \textit{nbumps5}), która bêdzie od tej pory definiowaæ liczbê wstrzasów sejsmicznych w zakresie $[10^5,10^{10})$. Z analizy wyrzucimy równie¿ zmienn± \textit{maxenergy}, która wydaje siê silnie zale¿na od zmiennej \textit{energy}.

\bigskip

Kolejn± zmienn±, któr± usuniemy z analizy bêdzie zmienna \textit{nbumps}, która jest liniowo zale¿na od zmiennych \textit{nbumps2, nbumps3, nbumps4} i \textit{nbumps5}.

\bigskip

Zajmijmy siê jeszcze zmiennymi nominalnymi. Niestety nie ka¿da metoda, któr± bêdziemy stosowaæ do analizy (np. QDA) dobrze sobie z nimi radzi. Bêdziemy wiêc pracowaæ na dwóch zestawach danych. Tam, gdzie siê da, bêdziemy korzystaæ z danych oryginalnych. W reszcie metod zamienimy sobie dane nominalny na dane ilo¶ciowe w nastêpuj±cy sposób:
   
Zmienn± \textit{seismic} przyjmuj±c± warto¶ci ze zbioru $\lbrace a,b,c,d\rbrace$ zamienimy na zmienn± \textit{seismic2} przyjmu±c± warto¶ci $\lbrace 0,1,2,3\rbrace$. W analogiczny sposób zamienimy zmienn± \textit{sesismoacoustic} na zmienn± \textit{sesismoacoustic2} oraz zmienn± \textit{ghazard} na zmienn± \textit{ghazard2}. Mo¿emy tak zrobiæ, gdy¿ ich warto¶ci reprezentuj± pewien porz±dek (a - ma³e, d - du¿e). Tak nie jest niestety w przypadku zmiennej \textit{shift}. Dlatego dla niej stworzymy zmienn± indykatorow± \textit{shift2} równ± $1$, gdy na zmianie byli górnicy, a $0$, gdy na zmianie by³a ekipa przygotowawcza. 

\bigskip

W ten sposób nasz zbiór danych w formie nominalnej przedstawia siê nastêpuj±co:

<<echo=FALSE,cache=TRUE>>=
se_wyb <- se[,-c(14:16,18,9)]
head(se_wyb,3)
@

A zbiór danych w formie liczbowej nastêpuj±co:

<<echo=FALSE,cache=TRUE>>=
se_r <- se_wyb
levels(se_r$seismic) <- c(0,1,2,3)
levels(se_r$seismoacoustic) <- c(0,1,2,3)
levels(se_r$shift) <- c(0,1)
levels(se_r$ghazard) <- c(0,1,2,3)
se_r[,c(1,2,3,8)] <- apply(se_r[,c(1,2,3,8)],2,as.numeric)
names(se_r)[c(1,2,3,8)] <- c("seismic2","seismoacoustic2","shift2","ghazard2")

head(se_r,3)
@

<<echo=FALSE,cache=TRUE>>=
set.seed(456)
ind <- sample(1:nrow(se_wyb), nrow(se_wyb)*2/3)

Train  <-  se_wyb[ind,]
Test  <-  se_wyb[-ind,]

Train2 <- se_r[ind,]
Test2 <- se_r[-ind,]
@



